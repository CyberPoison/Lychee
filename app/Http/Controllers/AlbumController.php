<?php

/** @noinspection PhpUndefinedClassInspection */

namespace App\Http\Controllers;

use AccessControl;
use App\Actions\Album\Archive;
use App\Actions\Album\Create;
use App\Actions\Album\CreateTag;
use App\Actions\Album\Move;
use App\Actions\Album\Prepare;
use App\Actions\Album\SetPublic;
use App\Actions\Album\UpdateTakestamps;
use App\Actions\Albums\Extensions\PublicIds;
use App\Actions\ReadAccessFunctions;
use App\Assets\Helpers;
use App\Factories\AlbumFactory;
use App\Http\Requests\AlbumRequests\AlbumIDRequest;
use App\Http\Requests\AlbumRequests\AlbumIDRequestInt;
use App\Http\Requests\AlbumRequests\AlbumIDsRequest;
use App\ModelFunctions\AlbumFunctions;
use App\Models\Album;
use App\Models\Logs;
use App\Models\Photo;
use App\Response;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Symfony\Component\HttpFoundation\StreamedResponse;

class AlbumController extends Controller
{
	use PublicIds;

	/**
	 * @var AlbumFunctions
	 */
	private $albumFunctions;

	/**
	 * @var readAccessFunctions
	 */
	private $readAccessFunctions;

	/**
	 * @var AlbumFactory
	 */
	private $albumFactory;

	/** @var UpdateTakestamps */
	private $updateTakestamps;

	/**
	 * @param AlbumFunctions      $albumFunctions
	 * @param ReadAccessFunctions $readAccessFunctions
	 */
	public function __construct(
		AlbumFunctions $albumFunctions,
		ReadAccessFunctions $readAccessFunctions,
		AlbumFactory $albumFactory,
		UpdateTakestamps $updateTakestamps
	) {
		$this->albumFunctions = $albumFunctions;
		$this->readAccessFunctions = $readAccessFunctions;
		$this->albumFactory = $albumFactory;
		$this->updateTakestamps = $updateTakestamps;
	}

	/**
	 * Add a new Album.
	 *
	 * @param Request $request
	 *
	 * @return false|string
	 */
	public function add(Request $request, Create $create)
	{
		$request->validate([
			'title' => 'string|required|max:100',
			'parent_id' => 'int|nullable',
		]);

		$album = $create->create($request['title'], $request['parent_id']);
		//! this may also be an RESPONSE not an ALBUM !!!
		//! FIXME

		return Response::json($album->id, JSON_NUMERIC_CHECK);
	}

	/**
	 * Add a new album generated by tags.
	 *
	 * @param Request $request
	 *
	 * @return false|string
	 */
	public function addByTags(Request $request, CreateTag $create)
	{
		$request->validate([
			'title' => 'string|required|max:100',
			'tags' => 'string',
		]);

		$album = $create->create($request['title'], $request['tags']);
		//! this may also be an RESPONSE not an ALBUM !!!
		//! FIXME

		return Response::json($album->id, JSON_NUMERIC_CHECK);
	}

	/**
	 * Provided an albumID, returns the album.
	 *
	 * @param Request $request
	 *
	 * @return array|string
	 */
	public function get(AlbumIDRequest $request, Prepare $prepare)
	{
		$album = $this->albumFactory->make($request['albumID']);

		return $prepare->do($album);
	}

	/**
	 * Provided an albumID, returns the album with only map related data.
	 *
	 * @param Request $request
	 *
	 * @return array|string
	 */
	public function getPositionData(AlbumIDRequest $request)
	{
		$request->validate(['includeSubAlbums' => 'string|required']);
		$return = [];

		$album = $this->albumFactory->make($request['albumID']);

		if ($album->smart) {
			$album->setAlbumIDs($this->getPublicAlbumsId());
			$photos_sql = $album->get_photos();
		} elseif ($request['includeSubAlbums']) {
			$photos_sql = $album->get_all_photos();
		} else {
			$photos_sql = $album->get_photos();
		}

		$full_photo = $album->is_full_photo_visible();

		$return['photos'] = $this->albumFunctions->photosLocationData($photos_sql, $full_photo);
		$return['id'] = $request['albumID'];

		return $return;
	}

	/**
	 * Provided the albumID and passwords, return whether the album can be accessed or not.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function getPublic(AlbumIDRequest $request)
	{
		$request->validate([
			'password' => 'string|nullable',
		]);

		return $this->albumFunctions->unlockAlbum($request['albumID'], $request['password']) ? 'true' : 'false';
	}

	/**
	 * Provided a title and an albumID, change the title of the album.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function setTitle(AlbumIDsRequest $request)
	{
		$request->validate([
			'title' => 'string|required|max:100',
		]);

		$albums = Album::whereIn('id', explode(',', $request['albumIDs']))->get();

		$no_error = true;
		$albums->each(function ($album) use (&$no_error, $request) {
			$album->title = $request['title'];
			$no_error &= $album->save();
		});

		return $no_error ? 'true' : 'false';
	}

	/**
	 * Change the sharing properties of the album.
	 *
	 * @param Request $request
	 *
	 * @return bool|string
	 */
	public function setPublic(AlbumIDRequestInt $request, SetPublic $setPublic)
	{
		$validated = $request->validate([
			'public' => 'integer|required',
			'visible' => 'integer|required',
			'nsfw' => 'integer|required',
			'downloadable' => 'integer|required',
			'share_button_visible' => 'integer|required',
			'full_photo' => 'integer|required',
			'password' => 'sometimes|string',
		]);

		$album = $this->albumFactory->make($request['albumID']);

		return $setPublic->do($album, $validated) ? 'true' : 'false'; // we should return a 422 or similar
	}

	/**
	 * Change the description of the album.
	 *
	 * @param Request $request
	 *
	 * @return bool|string
	 */
	public function setDescription(AlbumIDRequestInt $request)
	{
		$request->validate([
			'description' => 'string|nullable|max:1000',
		]);

		$album = Album::find($request['albumID']);

		$album->description = ($request['description'] == null) ? '' : $request['description'];

		return ($album->save()) ? 'true' : 'false';
	}

	/**
	 * Change show tags of the tag album.
	 *
	 * @param Request $request
	 *
	 * @return bool|string
	 */
	public function setShowTags(AlbumIDRequestInt $request)
	{
		$request->validate([
			'show_tags' => 'string|required|max:1000|min:1',
		]);

		$album = Album::find($request['albumID']);

		if (!$album->is_tag_album()) {
			Logs::error(__METHOD__, __LINE__, 'Could not change show tags on non tag album');

			return 'false';
		}

		$album->showtags = $request['show_tags'];

		return ($album->save()) ? 'true' : 'false';
	}

	/**
	 * Set the license of the Album.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function setLicense(AlbumIDRequestInt $request)
	{
		$request->validate([
			'license' => 'required|string',
		]);

		/**
		 * @var Album|null
		 */
		$album = Album::find($request['albumID']);

		$licenses = Helpers::get_all_licenses();

		$found = false;
		$i = 0;
		while (!$found && $i < count($licenses)) {
			if ($licenses[$i] == $request['license']) {
				$found = true;
			}
			$i++;
		}
		if (!$found) {
			Logs::error(__METHOD__, __LINE__, 'License not recognised: ' . $request['license']);

			return Response::error('License not recognised!');
		}

		$album->license = $request['license'];

		return $album->save() ? 'true' : 'false';
	}

	/**
	 * Delete the album and all pictures in the album.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function delete(AlbumIDsRequest $request)
	{
		$no_error = true;
		if ($request['albumIDs'] == '0') {
			$photos = Photo::select_unsorted(Photo::OwnedBy(AccessControl::id()))->get();
			foreach ($photos as $photo) {
				$no_error &= $photo->predelete();
				$no_error &= $photo->delete();
			}

			return $no_error ? 'true' : 'false';
		}
		$albums = Album::whereIn('id', explode(',', $request['albumIDs']))->get();

		foreach ($albums as $album) {
			$no_error &= $album->predelete();

			/**
			 * @var Album
			 */
			$parentAlbum = null;
			if ($album->parent_id !== null) {
				$parentAlbum = $album->parent;
				$minTS = $album->min_takestamp;
				$maxTS = $album->max_takestamp;
			}

			$no_error &= $album->delete();

			if ($parentAlbum !== null) {
				$no_error &= $this->updateTakestamps->singleAndSave($parentAlbum);
			}
		}

		return $no_error ? 'true' : 'false';
	}

	/**
	 * Merge albums. The first of the list is the destination of the merge.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function merge(AlbumIDsRequest $request)
	{
		// Convert to array
		$albumIDs = explode(',', $request['albumIDs']);
		// Get first albumID
		$albumID = array_shift($albumIDs);

		$album = Album::find($albumID);

		if ($album === null) {
			Logs::error(__METHOD__, __LINE__, 'Could not find specified albums');

			return 'false';
		}

		$photos = Photo::whereIn('album_id', $albumIDs)->get();
		$no_error = true;
		foreach ($photos as $photo) {
			$photo->album_id = $albumID;

			// just to be sure to handle ownership changes in the process.
			$photo->owner_id = $album->owner_id;

			$no_error &= $photo->save();
		}

		$albums = Album::whereIn('parent_id', $albumIDs)->get();
		$no_error = true;
		foreach ($albums as $album_t) {
			$album_t->parent_id = $albumID;

			// just to be sure to handle ownership changes in the process.
			$album_t->owner_id = $album->owner_id;
			$no_error &= $this->albumFunctions->setContentsOwner($album_t->id, $album->owner_id);

			$no_error &= $album_t->save();
		}
		$no_error &= $album->save();

		$albums = Album::whereIn('id', $albumIDs)->get();
		$takestamps = [];
		foreach ($albums as $album_t) {
			$parentAlbum = null;
			if ($album_t->parent_id !== null) {
				$parentAlbum = $album_t->parent;
				if ($parentAlbum === null) {
					Logs::error(__METHOD__, __LINE__, 'Could not find a parent album');
					$no_error = false;
				}
			}

			array_push($takestamps, $album_t->min_takestamp, $album_t->max_takestamp);

			$no_error &= $album_t->delete();

			if ($parentAlbum !== null) {
				$no_error &= $this->updateTakestamps->singleAndSave($parentAlbum);
			}
		}
		$no_error &= $this->updateTakestamps->singleAndSave($album);

		return $no_error ? 'true' : 'false';
	}

	/**
	 * Move multiple albums into another album.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function move(AlbumIDsRequest $request, Move $move)
	{
		// Convert to array
		$albumIDs = explode(',', $request['albumIDs']);

		// Get first albumID
		$albumID = array_shift($albumIDs);

		return $move->do($albumID, $albumIDs) ? 'true' : 'false';
	}

	/**
	 * Set if an album contains sensitive pictures.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function setNSFW(Request $request)
	{
		$request->validate([
			'albumID' => 'required|string',
		]);

		$album = Album::where('id', $request['albumID'])->first();
		$album->nsfw = ($album->nsfw != 1) ? 1 : 0;

		return $album->save() ? 'true' : 'false';
	}

	/**
	 * Define the default sorting type.
	 *
	 * @param Request $request
	 *
	 * @return string
	 */
	public function setSorting(AlbumIDRequest $request)
	{
		$request->validate([
			'typePhotos' => 'nullable',
			'orderPhotos' => 'required|string',
		]);

		/**
		 * @var Album|null
		 */
		$album = Album::find($request['albumID']);

		if ($album == null) {
			Logs::error(__METHOD__, __LINE__, 'Could not find specified album');

			return 'false';
		}

		Album::where('id', '=', $request['albumID'])
			->update(['sorting_col' => $request['typePhotos'] ?? '', 'sorting_order' => $request['orderPhotos']]);

		return 'true';
	}

	/**
	 * Return the archive of the pictures of the album and its subalbums.
	 *
	 * @param Request $request
	 *
	 * @return string|StreamedResponse
	 */
	public function getArchive(AlbumIDsRequest $request, Archive $archive)
	{
		if (Storage::getDefaultDriver() === 's3') {
			Logs::error(__METHOD__, __LINE__, 'getArchive not implemented for S3');

			return 'false';
		}

		$albumIDs = explode(',', $request['albumIDs']);

		return $archive->do($albumIDs);
	}

	/**
	 * Rebuild Takestamps.
	 *
	 * @param UpdateTakestamps $updateTakestamps
	 *
	 * @return string
	 */
	public function RebuildTakestamps(UpdateTakestamps $updateTakestamps)
	{
		$updateTakestamps->all();

		return 'true';
	}
}
